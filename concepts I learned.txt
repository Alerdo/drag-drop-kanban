


Okay the requirement of this project was to create a screen for a dash applic. this screen will be called process and we consist of a kanman style dashboard which dynamically generates cards and the database tracking the changes that are done in this card .so the requirement for the kanband dashboard are to have nine lanes each lanes to be titled ideas, correction of error report, short note ,Q&A model, pre-mortem, full note ,buy list, fail list. The main aim of these project was to create the drag and drop functionality of the cards between these Lanes so if we can create an I card on the idea lanes we can be able to drag it from there and drop it to the other Lanes and this changes need to be tracked on the database also all the cards created needs to be tracked on the Data Base etc point to create this project I start researching about this topic how to create dragon drop effect I decided to use react in the HTML5 new attribute draggable which makes possible that a certain element example a div can be dragged. 
For the more I started from the top level component the app component .initially I had it to display this columns or this lines on the user interface together with the corresponding name of its line . I done this through declaring an initial initial state about the column names and an initial state of the Lanes I created an array with 9 empty arrays because on a child component which will be the dropable zone out iterate through the empty race and there I would say the cards on the droppable zone I had I am iterating through each array of the column state which was saving the empty columns and in there I'm rendering another component draggable item which will be the component that will be able to drag right. Now on the droppable Zone component many things can happen first we have two handlers to functions the first one is handled drop on empty handle dropping on empty column which will be set to the empty column not on the card and as well we have handle drop on existing which will be the function responsible for the ondrop attribute that will be assigned to the each card so each card can be dropped to an existing card and each card can be dropped to an app empty column now to explain a bit further the rendering of the drawable zone initially it renders through the column state and then it does another end rendering through each column because the column state will have all the columns and now each columns will have many cards to iterate now on the first iteration of all the columns where we render the column name as well. As well we make sure that we assign a Plus button for the first Lane. Now on the iteration of the column itself not all the columns but on the column itself we have a diff surrounding the drug-able item this is done in purpose so the diff can take all the outer space of the column so there won't be a confusement between the function drop on empty space and drop on existing dragable item now how does the Dragon drop concept works is that for each card we set handle drag start function which will what this will do it will pass information such as the index the column index where the card is staying and the index inside the column to the event object and after we will have this object saved basically the original of the card on the event object after what we are going to do on the handle drop on empty as well on handle drop on existing basically the handler for the drop event we will use that information to look at the card make a new copy of the whole columns of the whole state take over that card and put it on the location we want the location we went will be the location we are dropping it. The location we are dropping it will be the index of the iteration that happens on the dropable zone Returned statement. Now about the Dragon Ball item we have a few requirements we need that initially to be inputs about stock name created they due date primarily secondary and list and attachments. So basically the analyst can be able to fill the stock name created they due date primary analyst secondary analyst at the attachment delete attachments when creating a card so that's how the logic of drag and drop works. As well it's required that once this fields are filled in they cannot be redidable apart from the secondary analyst and the attachment so I made this possible by following or better say using the disabled attribute for the inputs so for each Fields I decided to create inputs that will change the state of this new creative card. Get the discords can be created through the plus that we added on the first Lane when we iterate it for the drop-able Z and the plus had enough function handle add new card which would create new card with all these properties stock name created date etc so we already have the blueprints of the card and through the inputs on the Dragon Ball component we can change the state once we add all of these details on the field we have a button done editing which will make all the fills required to not be able to be edited later on they will be disabled the attribute disabled will be set to true through the don't editing button and then the analyst won't be able to edit this Fields anymore apart from the secondary analyst.I have also styled app.j cSS for better user interface. Now some difficulties I have through this front at part of the project was, first understanding how the iteration and display of the cards happens on the user interface, initially I had only the handle drop on existing function and when the column was empty there was no function to make possible dropping of the card point. Another issue with a dragon drop was that I had the problem where where drove dropping a item into another card was creating an extra card in the target column this was due to the event propagation and incorrect Handling of the drop event because the event propagation and explains how events like clicks or drags propagate through the DOM Tree in the context of my project and since I had the handlers for the column and for the Dragon Ball item when the card was being dropped on the Dragon on the column on the Dragon Ball item they then propagation was working on the column as well rendering twice and card. I also made sure in this project to add to handlers drop on existing and drop on empty columns in order so we can reorder the cards inside the column and as well drag and drop them in other columns now that we had the basic for the front end part I moved to the backend. 


The idea was to create a API that will so would serve as an interface between the front end and the database that I'll create to keep a track of the creation of the cards and chains of the lane of the cards together with all the details of the card I used not.j express and sqlize to send updates to the Data Base. Initially I initialize express and I created a server I created a database using postgresql after I created functionality for the API calls that will be made on the server initially I set it up equalized I initialize equalize SQL Isis or object relational mapping that serves as a middle point between the Data Base and the object orientated languages which helps us treat the database records as objects and it it's served perfectly here as it helped me modify the database very simply how this was happening was that the API calls on the functional output would send calls to the roots and on this route out handle this goals through the SQL so sqlize would do the updates for me in the database furthermore I created a model for my cards. In my terminal I managed to create a table with the columns name I needed. Later on I set it up routes. I first created the calls in the front end in the front end initially I struggled on how to display the information that is already on the database to the user interface how to pass that to the state. Obviously I was going to use the user effect that will would run upon the mounting of the component and would run only ones because of the condition that we put the empty dependency array so on this user effect out make a get call to the API created and take all the data from the database then create a new column with 9 empty columns iterates through the response data and extract the information needed for creating the new card after based on the States value of each card out push them to the appropriate state and that's how the rendering of the data already that database happen. After all the dragable item component I created functionality spirit so the handle editing done would update the display value of each of these inputs to true so some of them cannot be later be changed and it would make an API called when this buttons clicked to create a new record on the database with all the details needed on the back end the root of handle the postcode and we use sacralized to create a new record on the Data Base. On the drop of zone component where we had the two function responsible for handling the dropping of the cards will have a put called put called API call that would be responsible for changing the column name of the card dropped or basically changing the value of stage column in the database. This project was very very useful for me I managed to learn a lot starting from the use of react state management the event propagation the user fact the Dragon Ball attribute disabled attribute as well I used axios javaScript library to make the API calls. On the backend I got familiar with equalize ORM, which surprised me on how easy it was to manipulate the Data Base, and treat its record as objects.




SUM UP of my explaination of the PROJECT.



The requirement for this project was to develop a screen for a dash application. This screen, named "Process", consists of a Kanban-style dashboard. This dashboard dynamically generates cards, with a database tracking any changes made to these cards.

**Kanban Dashboard Features:**
- It is designed to have nine lanes. These lanes are titled: Ideas, Correction of Error Report, Short Note, Q&A Model, Pre-mortem, Full Note, Buy List, and Fail List.
- A primary objective was to implement a drag-and-drop functionality. This allows a card from one lane, such as "Ideas", to be moved to another lane. All changes must be tracked in the database.
- Every card that's created is also recorded in the database.

**Development Process:**
- **Research:** I began by researching how to create a drag-and-drop effect. I chose to use React along with the HTML5 attribute "draggable". This enables certain elements, like a `div`, to be dragged.
- **Frontend Design:** Starting from the top-level component, the app component was built to display the lanes and their titles. The state was initialized with column names and an array for the lanes, which had nine empty arrays. 
  - A child component, designed as the droppable zone, iterates through these arrays, setting cards accordingly.
  - For each card, a "handle drag start" function is set, allowing it to be dragged. The destination upon dropping determines its new location.
  - A draggable item component was used to make the cards draggable.
- **Backend Development:** The goal was to create an API that bridges the frontend and the database. This database would track card creations and modifications.
  - For the server, I used Express, and for the database, PostgreSQL was chosen.
  - Sequelize, an Object Relational Mapping (ORM) tool, was utilized to interact with the database. It allowed me to treat database records as objects, simplifying modifications.
  - Routes were set up for various API calls. A "get" call in the frontend fetched existing data from the database during the component's mounting process, using the React "useEffect" hook.
  - Drag-and-drop functionality was further enhanced with functions to handle the drop events, updating the database accordingly.

**Challenges Faced:**
- Understanding how cards are displayed was initially confusing.
- There was an issue where dragging an item into another card would create an extra card in the target column due to event propagation. This required a deeper understanding of how events like clicks or drags propagate through the DOM tree.
- On the backend, understanding Sequelize's ORM was an initial hurdle, but its utility in simplifying database operations was soon realized.

**Technologies and Libraries Used:**
- React for frontend development.
- Axios, a JavaScript library, for API calls.
- CORS, Middleware for Express to enable Cross-Origin Resource Sharing.
- Express for backend server setup.
- Sequelize as the ORM to facilitate database interactions.


I have also styled the application using "app.css" to enhance the user interface.

Overall, this project was immensely educational. It helped me understand React's state management, event propagation, and other intricacies of web development. On the backend, I got acquainted with Sequelize's ORM, appreciating its ease in database manipulations and treating records as objects.

---

